# Why IMake

## 缘起

现阶段对 IMakeCore 的定义是：`IMakeCore 是基于 cmake 和 qmake 的 c++ 源代码的包管理系统`。

IMakeCore 写作的最初原因是 IWebCore 的代码和功能越来越多，有了不同方向的功能可以拆分使用和组合使用。在一开始的时候，我独自封装出 qmake 中的 pri 包，如果需要哪个功能，我就把相关的 pri 手动写入配置中导进去。

还有一点，另外对于传统的包管理而言，他们首先是将代码编译成动态库或者静态库在引入项目中去，而这一点对于 IWebCore 中的类并不适用，IWebCore 强烈依赖对象的静态初始化做依赖注入的功能，所以代码编译成静态库或者动态库会导致odr 相关的问题。

再有一点，IWebCore 不仅仅是几个功能的集合而已。在IWebCore 的规划中，不仅仅是目前的这些包，更是有一些额外的包来进行功能的扩展。比如在 IHttpCore 中，之后会有cors, cache, ranges, session， 静态文件服务，等一系列的提供各种http增强服务的扩展功能。在IHttpCore之外，也需要 对 redis, mongodb等数据库进行封装，对 rpc，对 ws 进行封装等等。这些都会产生大量的包。而这些包如果能够被管理起来就会大大的方便用户的开发。

与此作为对照的，我们可以举例比如 maven/gradle之于 spring 框架。正是由于maven 这样的包管理系统的存在，用户在使用 spring 的时候可以很方便的，几乎无成本的集成这些库，来扩展自己的功能和使用的边界。还有可以举例的如 pip/pypi 之于django这样的平台等。

所以写 IMake 的最初目的就是能够管理在 IWebCore 这套框架中使用到的库，让IWebCore不仅仅成为一系列的库，通过这些扩展而成为一个平台。

## 发展

IMake 最初编写的时候是通过 pri 来定义库和引用库。在之后的一次次的迭代的过程中，功能逐渐的丰富起来。

首先，我们在qmake之外支持了 cmake。用户不再需要自己写 pri 或者 cmake 文件来定义一个库了，而是我定义了一系列的cmake 和qmake 功能函数来自动的扫描整个包的内容，从而来配置出这个包。在 package.json 中的 autoScan 字段便是由此而来。这里特殊说明一下，用户仍然可以编写 pri ,和 cmake 文件来导入库，这样可以提供给用户在需要的时候可以自己定义一些额外的功能。

其次，我建立了 IPubCore 这个网站。这个网站的目的是为了上传，查找，管理和分发用户定义的包。这个的功能类似于pypi / maven/ npm 这些网站。这里用户可以上传自己的包，来分享给大家使用。通过这个网站用户对于想用什么样的包有了直观的感受。额外说明一下，这个网站是我使用 IHttp 和 IRdb 这两个子框架从零一点点搭建起来的。前端使用 react,但是 react 代码基本上都是 AI 生成而来，需要的地方我手动修改了一下。

再者，用户总是需要在自己的的电脑上进行操作。由此，我写了一个 IPubCmd 工具，这个工具由 `ipc` 这个命令调起。这个程序是由 ICmdCore 子框架编写而成。在ipc 中，用户可以很方便的将 IMakeCore 包引入到用户已有的项目中去，可以查找和下载各种的包。

在最近我又对整个系统进行了重构。这次重构的目的是是为了丰富各种包，激发用户上传包的活力。这个描述听起来很高大上，但是其实很简单，就是降低用户上传包的门槛。之前一个包名只能被上传一次，现在我在包名前面添加了一个用户的publiser 限定，那么同一个包就可以被不同的用户封装，上传。比如说 zip 包，A 同学可以自己封装一个，B 同学也可以封装一个，甚至C同学可以把A同学的包改一下 publisher 字段再自己上传上去。

不管A,B还是 C同学上传包，这些包的author 字段，和license 等都需要包留，以符合开源协议的要求。这里的意思是，我把一个包的上传者和作者做了一个切割，包的作者不能够改变，但是上传者不一定是包的作者，可以是任何人，只要符合开源协议即可。

此时IPubCore 中的包会有很多，同时良莠不齐。在解决了包少的问题上，我之后会添加排序算法，让优秀的包能够被排在前面，这里的排序可以有用户的star, 下载量等因素决定。如果对于一些包，比如特别优秀，或者是原作者上传的，那么这些包会成为`官方包`，用户在引入这些包的时候可以省略写 publisher 这个字段。官方包的默认搜索排序将会更靠前。



## 展望

